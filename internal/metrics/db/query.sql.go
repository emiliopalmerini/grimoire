// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const getAIStats = `-- name: GetAIStats :one
SELECT COUNT(*) as total_calls,
       COALESCE(SUM(prompt_length), 0) as total_prompt_tokens,
       COALESCE(SUM(response_length), 0) as total_response_tokens,
       COALESCE(AVG(latency_ms), 0) as avg_latency_ms
FROM ai_invocations
WHERE datetime(created_at) >= datetime(?1)
  AND datetime(created_at) <= datetime(?2)
`

type GetAIStatsParams struct {
	FromDate interface{}
	ToDate   interface{}
}

type GetAIStatsRow struct {
	TotalCalls          int64
	TotalPromptTokens   interface{}
	TotalResponseTokens interface{}
	AvgLatencyMs        interface{}
}

func (q *Queries) GetAIStats(ctx context.Context, arg GetAIStatsParams) (GetAIStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAIStats, arg.FromDate, arg.ToDate)
	var i GetAIStatsRow
	err := row.Scan(
		&i.TotalCalls,
		&i.TotalPromptTokens,
		&i.TotalResponseTokens,
		&i.AvgLatencyMs,
	)
	return i, err
}

const getAIStatsByModel = `-- name: GetAIStatsByModel :many
SELECT model, COUNT(*) as count,
       COALESCE(SUM(prompt_length), 0) as prompt_tokens,
       COALESCE(SUM(response_length), 0) as response_tokens,
       COALESCE(AVG(latency_ms), 0) as avg_latency_ms
FROM ai_invocations
WHERE datetime(created_at) >= datetime(?1)
  AND datetime(created_at) <= datetime(?2)
GROUP BY model ORDER BY count DESC
`

type GetAIStatsByModelParams struct {
	FromDate interface{}
	ToDate   interface{}
}

type GetAIStatsByModelRow struct {
	Model          string
	Count          int64
	PromptTokens   interface{}
	ResponseTokens interface{}
	AvgLatencyMs   interface{}
}

func (q *Queries) GetAIStatsByModel(ctx context.Context, arg GetAIStatsByModelParams) ([]GetAIStatsByModelRow, error) {
	rows, err := q.db.QueryContext(ctx, getAIStatsByModel, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAIStatsByModelRow{}
	for rows.Next() {
		var i GetAIStatsByModelRow
		if err := rows.Scan(
			&i.Model,
			&i.Count,
			&i.PromptTokens,
			&i.ResponseTokens,
			&i.AvgLatencyMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommandStats = `-- name: GetCommandStats :many
SELECT command, COUNT(*) as count, AVG(duration_ms) as avg_duration_ms
FROM command_executions
WHERE datetime(executed_at) >= datetime(?1)
  AND datetime(executed_at) <= datetime(?2)
  AND (?3 = '' OR command = ?3)
GROUP BY command
ORDER BY count DESC
`

type GetCommandStatsParams struct {
	FromDate      interface{}
	ToDate        interface{}
	CommandFilter interface{}
}

type GetCommandStatsRow struct {
	Command       string
	Count         int64
	AvgDurationMs sql.NullFloat64
}

func (q *Queries) GetCommandStats(ctx context.Context, arg GetCommandStatsParams) ([]GetCommandStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommandStats, arg.FromDate, arg.ToDate, arg.CommandFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommandStatsRow{}
	for rows.Next() {
		var i GetCommandStatsRow
		if err := rows.Scan(&i.Command, &i.Count, &i.AvgDurationMs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctCommands = `-- name: GetDistinctCommands :many
SELECT DISTINCT command FROM command_executions ORDER BY command
`

func (q *Queries) GetDistinctCommands(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctCommands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var command string
		if err := rows.Scan(&command); err != nil {
			return nil, err
		}
		items = append(items, command)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailureCount = `-- name: GetFailureCount :one
SELECT COUNT(*) as failures FROM command_executions
WHERE exit_code != 0
  AND datetime(executed_at) >= datetime(?1)
  AND datetime(executed_at) <= datetime(?2)
  AND (?3 = '' OR command = ?3)
`

type GetFailureCountParams struct {
	FromDate      interface{}
	ToDate        interface{}
	CommandFilter interface{}
}

func (q *Queries) GetFailureCount(ctx context.Context, arg GetFailureCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFailureCount, arg.FromDate, arg.ToDate, arg.CommandFilter)
	var failures int64
	err := row.Scan(&failures)
	return failures, err
}

const getRecentAIInvocations = `-- name: GetRecentAIInvocations :many
SELECT id, command, model, prompt_length, response_length, latency_ms, success, error, created_at FROM ai_invocations
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentAIInvocations(ctx context.Context, limit int64) ([]AiInvocation, error) {
	rows, err := q.db.QueryContext(ctx, getRecentAIInvocations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AiInvocation{}
	for rows.Next() {
		var i AiInvocation
		if err := rows.Scan(
			&i.ID,
			&i.Command,
			&i.Model,
			&i.PromptLength,
			&i.ResponseLength,
			&i.LatencyMs,
			&i.Success,
			&i.Error,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentCommands = `-- name: GetRecentCommands :many
SELECT id, command, command_type, duration_ms, exit_code, flags, executed_at FROM command_executions
WHERE (?1 = '' OR command = ?1)
ORDER BY executed_at DESC
LIMIT ?2
`

type GetRecentCommandsParams struct {
	CommandFilter interface{}
	LimitCount    int64
}

func (q *Queries) GetRecentCommands(ctx context.Context, arg GetRecentCommandsParams) ([]CommandExecution, error) {
	rows, err := q.db.QueryContext(ctx, getRecentCommands, arg.CommandFilter, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CommandExecution{}
	for rows.Next() {
		var i CommandExecution
		if err := rows.Scan(
			&i.ID,
			&i.Command,
			&i.CommandType,
			&i.DurationMs,
			&i.ExitCode,
			&i.Flags,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalCommands = `-- name: GetTotalCommands :one
SELECT COUNT(*) as total FROM command_executions
WHERE datetime(executed_at) >= datetime(?1)
  AND datetime(executed_at) <= datetime(?2)
  AND (?3 = '' OR command = ?3)
`

type GetTotalCommandsParams struct {
	FromDate      interface{}
	ToDate        interface{}
	CommandFilter interface{}
}

func (q *Queries) GetTotalCommands(ctx context.Context, arg GetTotalCommandsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalCommands, arg.FromDate, arg.ToDate, arg.CommandFilter)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const insertAIInvocation = `-- name: InsertAIInvocation :one
INSERT INTO ai_invocations (command, model, prompt_length, response_length, latency_ms, success, error)
VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, command, model, prompt_length, response_length, latency_ms, success, error, created_at
`

type InsertAIInvocationParams struct {
	Command        string
	Model          string
	PromptLength   sql.NullInt64
	ResponseLength sql.NullInt64
	LatencyMs      sql.NullInt64
	Success        int64
	Error          sql.NullString
}

func (q *Queries) InsertAIInvocation(ctx context.Context, arg InsertAIInvocationParams) (AiInvocation, error) {
	row := q.db.QueryRowContext(ctx, insertAIInvocation,
		arg.Command,
		arg.Model,
		arg.PromptLength,
		arg.ResponseLength,
		arg.LatencyMs,
		arg.Success,
		arg.Error,
	)
	var i AiInvocation
	err := row.Scan(
		&i.ID,
		&i.Command,
		&i.Model,
		&i.PromptLength,
		&i.ResponseLength,
		&i.LatencyMs,
		&i.Success,
		&i.Error,
		&i.CreatedAt,
	)
	return i, err
}

const insertCommandExecution = `-- name: InsertCommandExecution :one
INSERT INTO command_executions (command, command_type, duration_ms, exit_code, flags)
VALUES (?, ?, ?, ?, ?) RETURNING id, command, command_type, duration_ms, exit_code, flags, executed_at
`

type InsertCommandExecutionParams struct {
	Command     string
	CommandType string
	DurationMs  int64
	ExitCode    int64
	Flags       sql.NullString
}

func (q *Queries) InsertCommandExecution(ctx context.Context, arg InsertCommandExecutionParams) (CommandExecution, error) {
	row := q.db.QueryRowContext(ctx, insertCommandExecution,
		arg.Command,
		arg.CommandType,
		arg.DurationMs,
		arg.ExitCode,
		arg.Flags,
	)
	var i CommandExecution
	err := row.Scan(
		&i.ID,
		&i.Command,
		&i.CommandType,
		&i.DurationMs,
		&i.ExitCode,
		&i.Flags,
		&i.ExecutedAt,
	)
	return i, err
}
